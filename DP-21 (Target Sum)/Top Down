//the problem in the memoization solution was that the dp starts from 0 and when the target goes below 0 then the 
//code cant handle that  and gives index out of bound error so to solve this we can use memoization when target>0
//not a very good or fully optimised solution.

class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int totalsum=0;
        for(int i=0;i<nums.length;i++){
            totalsum+=nums[i];
        }
        int dp[][]=new int[nums.length+1][2001];
        for(int row[]:dp){
            Arrays.fill(row,-1);
        }
        return help(nums.length-1,target,nums,dp);
    }

    public int help(int i,int target,int[] arr,int[][] dp){
        //base case if reached 0th idx and target=0
        if(i==0){
            if(arr[0]+target==0 && arr[0]-target==0){
                return 2; //imp step
            }
            else if(arr[0]+target==0){
                return 1;
            }
            else if(arr[0]-target==0){
                return 1;
            }
            return 0;
        }
        if(target>0){
            if(dp[i][target]!=-1){
                return dp[i][target];
            }
        }

        //all cases 
        int add=help(i-1,target-arr[i],arr,dp);
        int subtract=help(i-1,target+arr[i],arr,dp);
        if(target>0){
            return dp[i][target]=add+subtract;
        }
        return add+subtract;
    }
}